#![no_main]
#![no_std]
#![allow(clippy::empty_loop)]

use msp430fr2355 as _;
use panic_msp430 as _;

use msp430_rt::entry;

#[entry]
fn main() -> ! {
	// In C we usually import a header file like msp430.h that defines all the registers for us as macros.
	// The equivalent in Rust is known as a Peripheral Access Crate (PAC).

	// Peripheral Access Crates can be autogenerated based on an 'SVD' file provided by a manufacturer 
	// (in much the same way that C header files are!)

	// A PAC provides all the registers on a device through a centralised method.
	// This object can only be retrieved once. This provides a single source of truth
	// for all register values. This lets us e.g. assign ownership of registers to other objects,
	// or consume them to prevent them being accidentally modified afterwards.
	let regs = msp430fr2355::Peripherals::take().unwrap();

	// Registers are exposed through writer methods that take a closure.
	// If you're worried that this is all sounding very 'heavy' for an embedded system, don't worry!
	// All of this resolves to a single operation at runtime!

	// Set the P1DIR register to have value 1:
	regs.P1.p1dir.write(|w| unsafe{ w.bits(1) });
	
	// The following methods are usually available on MSP430 registers:

	// The MSP430 has instructions for setting or clearing bits in a register without affecting the other bits:
	// set_bits() - sets the individual bits that are set in the closure, leaving the rest unchanged. This is done as a single atomic operation.
	// clear_bits() - clears the individual bits that are cleared in the closure, leaving the rest unchanged. This is done as a single atomic operation.
	// read() - reads from the register in a single atomic operation.

	// reset() - writes the reset value as specified in the datasheet to the register in a single atomic operation.
	// write() - starting from the reset value, apply the changes in the closure then write this to the register in a single atomic operation.

	// modify() - Reads the current register value, performs the modifications in the closure, 
	// then writes the new value back. This is equivalent to `REG = REG & ~bits` or `REG = REG | bits` in C.

	// The bits() method is always available which reads / writes all the bits in the register, 
    // but registers with separate bitfields can have each bitfield set separately.

	// Toggle the last bit of P1OUT:
	regs.P1.p1out.modify(|r, w| unsafe { w.bits(r.bits() ^ 1) });

	// Clear the LOCKLPM5 bit in PM5CTL0. This is an example of a register with separate bitfields
	// so the code is quite expressive:
	unsafe{ regs.PMM.pm5ctl0.clear_bits(|w| w.locklpm5().clear_bit()) };
	
	// This is a lot better than the raw memory operations in the previous example, but it's still a bit clunky.
	// There's still 'unsafe' in some places as we need to verify whether our operations produce valid 
	// register values (e.g. avoiding touching reserved bits, etc.) 
    // Not to mention you might (for instance) forget to clear the LOCKLPM5 bit!
    // Can we do better?

    loop {}
}
