#![no_main]
#![no_std]
#![allow(clippy::empty_loop)]

use msp430fr2355 as _;
use panic_msp430 as _;

use msp430_rt::entry;

#[entry]
fn main() -> ! {
	// In C we usually import a header file like msp430.h that defines all the registers for us as macros.
	// The equivalent in Rust is known as a Peripheral Access Crate (PAC).

	// Peripheral Access Crates can be autogenerated based on an 'SVD' file provided by a manufacturer 
	// (in much the same way that C header files are!)

	// A PAC provides all the registers on a device through a centralised method.
	// This object can only be retrieved once. This provides a single source of truth
	// for all register values. This lets us e.g. assign ownership of registers to other objects,
	// or consume them to prevent them being accidentally modified afterwards.
	let regs = msp430fr2355::Peripherals::take().unwrap();

	// Registers are exposed through writer methods that take a closure.
	// If you're worried that this is all sounding very 'heavy' for an embedded system, don't worry!
	// All of this resolves to a single operation at runtime!

	// Set the P1DIR register to have value 1:
	regs.P1.p1dir.write(|w| unsafe{ w.bits(1) });
	// Within a write/read closure the bits() method is always available, which reads / writes 
	// all the bits in the register, but registers with separate bitfields can have each bitfield set separately.
	
	// The MSP430 has several CPU different instructions it can use for reading and writing to registers. It can atomically
	// set, clear, or toggle bits. 
	// Of course, you can always read the register, modify the value, and write the new value back in a non-atomic manner.
	// As a result, the following methods are usually available on MSP430 registers:
	
	// set_bits()
	// Sets the individual bits that are set in the closure, leaving the rest unchanged. 
	// This is done as a single CPU instruction.
	
	// clear_bits()
	// Clears the individual bits that are cleared in the closure, leaving the rest unchanged. 
	// This is done as a single CPU instruction.
	
	// toggle_bits()
	// Toggles the individual bits that are *set* in the closure, leaving the rest unchanged. 
	// This is done as a single CPU instruction.
	
	// read() 
	// Reads from the register with a single CPU instruction.

	// reset()
	// Writes the reset value as specified in the datasheet to the register in a single CPU instruction.

	// write()
	// Starting from the reset value, make the changes specified in the closure, 
	// then write this to the register with a single CPU instruction.

	// modify() 
	// Reads the current register value, performs the modifications in the closure, 
	// then writes the new value back. This is equivalent to `REG = REG & ~bits` or `REG = REG | bits` in C.

	// Toggle the last bit of P1OUT:
	unsafe { regs.P1.p1out.toggle_bits(|w| w.bits(1)) };
	// If the MSP430 didn't support atomic toggling, we could always do:
	// regs.P1.p1out.modify(|r, w| unsafe { w.bits(r.bits() ^ 1) });


	// Clear the LOCKLPM5 bit in PM5CTL0. This is an example of a register with separate bitfields
	// so the code is quite expressive:
	unsafe{ regs.PMM.pm5ctl0.clear_bits(|w| w.locklpm5().clear_bit()) };
	
	// This is a lot better than the raw memory operations in the previous example, but it's still a bit clunky.
	// There's still 'unsafe' in some places as we need to verify whether our operations produce valid 
	// register values (e.g. avoiding touching reserved bits, etc.) 
    // Not to mention you might (for instance) forget to clear the LOCKLPM5 bit!
    // Can we do better?

    loop {}
}
